/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CLParser.jj */
/*@egen*/options {
    STATIC = false;  // Ensures the parser is non-static
}

PARSER_BEGIN(CLParser)

import java.util.Scanner;

public class CLParser/*@bgen(jjtree)*/implements CLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCLParserState jjtree = new JJTCLParserState();

/*@egen*/
    public static SymbolTable symbolTable = new SymbolTable();  // Global symbol table
    private StringBuilder parseTree = new StringBuilder();  // For building the parse tree output
    private int indentLevel = 0;  // To manage indentation for printing

    public static void main(String[] args) {
        try {
            CLParser parser = new CLParser(System.in);  // Create parser with input from System.in
            parser.startProgram();  // Start parsing
            System.out.println("Program parsed successfully.");
            System.out.println(parser.getParseTree());  // Print the parse tree
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    public String getParseTree() {
        return parseTree.toString();  // Return the constructed parse tree
    }

    private void indent() {
        for (int i = 0; i < indentLevel; i++) {
            parseTree.append("\u2502   ");
        }
    }

    private void increaseIndent() {
        indentLevel++;
    }

    private void decreaseIndent() {
        indentLevel--;
    }

    private void appendToParseTree(String text) {
        indent();  // Handle indentation
        parseTree.append(text).append("\n");  // Append the text to the parse tree
    }
}

PARSER_END(CLParser)

SKIP : {
    " " | "\t" | "\n" | "\r"  // Skip spaces, tabs, newlines, and carriage returns
}

TOKEN : {
    < START_PROGRAM : "startProgram" >
|   < END_PROGRAM : "endProgram" >
|   < VARIABLES : "variables:" >
|   < CODE : "code:" >
|   < IDENTIFIER : (["a"-"z", "A"-"Z"])+ >
|   < INTEGER : (["0"-"9"])+ >
|   < FLOAT : (["0"-"9"])+ "." (["0"-"9"])+ >
|   < STRING : "\"" (~["\""])* "\"" >  // String token with multiple characters
|   < CHAR : "'" ~["'"] "'" >
|   < SEMICOLON : ";" >
|   < ASSIGN : "=" >
|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULTIPLY : "*" >
|   < DIVIDE : "/" >
|   < LESS_THAN_EQUAL : "<=" >
|   < GREATER_THAN_EQUAL : ">=" >
|   < EQUAL : "==" >
|   < NOT_EQUAL : "<>" >
}

void startProgram() :
{/*@bgen(jjtree) startProgram */
  SimpleNode jjtn000 = new SimpleNode(JJTSTARTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) startProgram */
    try {
/*@egen*/
    <START_PROGRAM> { 
        appendToParseTree("startProgram");
        increaseIndent();  // Indent when starting program block
    }
    variablesBlock() { 
        appendToParseTree("variablesBlock"); 
    }
    codeBlock() { 
        appendToParseTree("codeBlock"); 
    }
    <END_PROGRAM>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { 
        appendToParseTree("endProgram");
        decreaseIndent();  // Decrease indentation when ending program block
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void variablesBlock() :
{/*@bgen(jjtree) variablesBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTVARIABLESBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) variablesBlock */
    try {
/*@egen*/
    <VARIABLES> { 
        appendToParseTree("VARIABLES"); 
        increaseIndent();  // Indent when starting variables block
    }
    ( variableDeclaration() { /* Handle each variable */ } )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
        decreaseIndent();  // Decrease indentation after variables block
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void codeBlock() :
{/*@bgen(jjtree) codeBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTCODEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) codeBlock */
    try {
/*@egen*/
    <CODE> { 
        appendToParseTree("CODE"); 
        increaseIndent();  // Indent when starting code block
    }
    ( statement() { /* Handle each statement */ } )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { 
        decreaseIndent();  // Decrease indentation after code block
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void variableDeclaration() :
{/*@bgen(jjtree) variableDeclaration */
    SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token id;
    Object value;
}
{/*@bgen(jjtree) variableDeclaration */
    try {
/*@egen*/
    id = <IDENTIFIER>
    <ASSIGN>
    ( value = <INTEGER> {
        // Adding variable to symbol table as INTEGER
        symbolTable.addVariable(id.image, SymbolTable.Type.INTEGER, Integer.parseInt(((Token)value).image));
        appendToParseTree("variableDeclaration -> IDENTIFIER (" + id.image + ") ASSIGN (=) INTEGER (" + value + ")");
    }
    | value = <FLOAT> {
        // Adding variable to symbol table as FLOAT
        symbolTable.addVariable(id.image, SymbolTable.Type.FLOAT, Float.parseFloat(((Token)value).image));
        appendToParseTree("variableDeclaration -> IDENTIFIER (" + id.image + ") ASSIGN (=) FLOAT (" + value + ")");
    }
    | value = <STRING> {
        // Adding variable to symbol table as STRING
        symbolTable.addVariable(id.image, SymbolTable.Type.STRING, ((Token)value).image);
        appendToParseTree("variableDeclaration -> IDENTIFIER (" + id.image + ") ASSIGN (=) STRING (\"" + value + "\")");
    }
    | value = <CHAR> {
        // Adding variable to symbol table as CHAR
        symbolTable.addVariable(id.image, SymbolTable.Type.CHAR, ((Token)value).image.charAt(1));  // Only take the character between single quotes
        appendToParseTree("variableDeclaration -> IDENTIFIER (" + id.image + ") ASSIGN (=) CHAR ('" + value + "')");
    }
    )
    <SEMICOLON>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement() :
{/*@bgen(jjtree) statement */
    SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token id;
    Object exprValue;
}
{/*@bgen(jjtree) statement */
    try {
/*@egen*/
    id = <IDENTIFIER>
    <ASSIGN>
    exprValue = expression() 
    <SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        // Updating variable in symbol table
        if (symbolTable.isDeclared(id.image)) {
            symbolTable.updateVariable(id.image, exprValue);  // Update variable in symbol table
            appendToParseTree("statement -> IDENTIFIER (" + id.image + ") ASSIGN (=) EXPRESSION");
        } else {
            throw new ParseException("Variable " + id.image + " not declared.");
        }
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Object expression() :
{/*@bgen(jjtree) expression */
    SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Object left, right;
}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    left = term() 
    (
        <PLUS> right = term() { left = (Float)left + (Float)right; }
      | <MINUS> right = term() { left = (Float)left - (Float)right; }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return left; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Object term() :
{/*@bgen(jjtree) term */
    SimpleNode jjtn000 = new SimpleNode(JJTTERM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Object left, right;
}
{/*@bgen(jjtree) term */
    try {
/*@egen*/
    left = factor() 
    (
        <MULTIPLY> right = factor() { left = (Float)left * (Float)right; }
      | <DIVIDE> right = factor() { left = (Float)left / (Float)right; }
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return left; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Object factor() :
{/*@bgen(jjtree) factor */
    SimpleNode jjtn000 = new SimpleNode(JJTFACTOR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token id;
    Object value;
}
{/*@bgen(jjtree) factor */
    try {
/*@egen*/
    (
        id = <INTEGER>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { 
            appendToParseTree("factor -> INTEGER (" + id.image + ")");
            return Integer.parseInt(id.image); 
        }
      | id = <FLOAT>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { 
            appendToParseTree("factor -> FLOAT (" + id.image + ")");
            return Float.parseFloat(id.image); 
        }
      | id = <IDENTIFIER>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ { 
            // Return variable value from the symbol table
            if (symbolTable.isDeclared(id.image)) {
                appendToParseTree("factor -> IDENTIFIER (" + id.image + ")");
                return symbolTable.getVariable(id.image); 
            } else {
                throw new ParseException("Variable " + id.image + " not declared.");
            }
        }
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
